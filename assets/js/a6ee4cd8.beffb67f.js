"use strict";(self.webpackChunkwpyoga_docusaurus_blog=self.webpackChunkwpyoga_docusaurus_blog||[]).push([[111],{3905:function(e,n,t){t.d(n,{Zo:function(){return h},kt:function(){return _}});var l=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,l,a=function(e,n){if(null==e)return{};var t,l,a={},i=Object.keys(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=l.createContext({}),m=function(e){var n=l.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},h=function(e){var n=m(e.components);return l.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return l.createElement(l.Fragment,{},n)}},u=l.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),u=m(t),_=a,d=u["".concat(s,".").concat(_)]||u[_]||c[_]||i;return t?l.createElement(d,o(o({ref:n},h),{},{components:t})):l.createElement(d,o({ref:n},h))}));function _(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var m=2;m<i;m++)o[m]=t[m];return l.createElement.apply(null,o)}return l.createElement.apply(null,t)}u.displayName="MDXCreateElement"},136:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return m},assets:function(){return h},toc:function(){return c},default:function(){return _}});var l=t(3117),a=t(102),i=(t(7294),t(3905)),o=["components"],r={title:"Manual Profiling of Bash Script Execution",tags:["bash","profiling"]},s=void 0,m={permalink:"/blog/2021/07/11/manual-profiling-bash-script",editUrl:"https://github.com/wpyoga/wpyoga.github.io/edit/master/blog/2021-07-11-manual-profiling-bash-script.md",source:"@site/blog/2021-07-11-manual-profiling-bash-script.md",title:"Manual Profiling of Bash Script Execution",description:"Sometimes, we would like to know how long a command takes, and which part of the script takes the longest time to run.",date:"2021-07-11T00:00:00.000Z",formattedDate:"July 11, 2021",tags:[{label:"bash",permalink:"/blog/tags/bash"},{label:"profiling",permalink:"/blog/tags/profiling"}],truncated:!0,authors:[],prevItem:{title:"Bash Shell Slow Start-up",permalink:"/blog/2021/07/11/bash-slow-start"},nextItem:{title:"Using a `.bashrc.d` directory instead of just `.bashrc`",permalink:"/blog/2021/07/10/bashrc-directory"}},h={authorsImageUrls:[]},c=[{value:"The method",id:"the-method",children:[],level:2},{value:"An unforeseen problem",id:"an-unforeseen-problem",children:[],level:2},{value:"A naive &quot;fix&quot;",id:"a-naive-fix",children:[],level:2},{value:"The proper fix",id:"the-proper-fix",children:[],level:2},{value:"An alternative method",id:"an-alternative-method",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:c};function _(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,l.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sometimes, we would like to know how long a command takes, and which part of the script takes the longest time to run."),(0,i.kt)("h2",{id:"the-method"},"The method"),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"time"),", which is a special bash keyword. Instead of using a separate ",(0,i.kt)("inlineCode",{parentName:"p"},"/usr/bin/time")," command, it can be less overhead to use the keyword."),(0,i.kt)("p",null,"Following the implementation ",(0,i.kt)("a",{parentName:"p",href:"/blog/2021/07/10/bashrc-directory#self-cleaning-implementation"},"here"),", we add some profiling info to ",(0,i.kt)("inlineCode",{parentName:"p"},"~/.bashrc"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'for i in "${HOME}/.bashrc.d"/[0-9][0-9]-*.bashrc; do\n  if [ -r "$i" ]; then\n    export TIMEFORMAT="%R $i"\n    time . "$i"\n  fi\ndone\nunset i\n')),(0,i.kt)("p",null,"This showed that ",(0,i.kt)("inlineCode",{parentName:"p"},"nvm")," makes bash load slowly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0.034 /home/william/.bashrc.d/00-default.bashrc\n0.000 /home/william/.bashrc.d/50-android-sdk.bashrc\n0.000 /home/william/.bashrc.d/50-android-studio.bashrc\n0.002 /home/william/.bashrc.d/50-asdf.bashrc\n0.261 /home/william/.bashrc.d/50-nvm.bashrc\n0.036 /home/william/.bashrc.d/50-sdkman.bashrc\n0.000 /home/william/.bashrc.d/90-gradle-opts.bashrc\n")),(0,i.kt)("h2",{id:"an-unforeseen-problem"},"An unforeseen problem"),(0,i.kt)("p",null,"So, I began timing its execution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"nvm_process_parameters() {\n  local NVM_AUTO_MODE\n  NVM_AUTO_MODE='use'\n  while [ $# -ne 0 ]; do\n    case \"$1\" in\n      --install) NVM_AUTO_MODE='install' ;;\n      --no-use) NVM_AUTO_MODE='none' ;;\n    esac\n    shift\n  done\n  export TIMEFORMAT='%R nvm_auto'\n  time nvm_auto \"${NVM_AUTO_MODE}\"\n}\n\nnvm_process_parameters \"$@\"\n")),(0,i.kt)("p",null,"also:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_auto() {\n  echo nvm_auto "$@"\n  local NVM_MODE\n  NVM_MODE="${1-}"\n  local VERSION\n  local NVM_CURRENT\n  if [ "_${NVM_MODE}" = \'_install\' ]; then\n    VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)"\n    if [ -n "${VERSION}" ]; then\n      nvm install "${VERSION}" >/dev/null\n    elif nvm_rc_version >/dev/null 2>&1; then\n      nvm install >/dev/null\n    fi\n  elif [ "_$NVM_MODE" = \'_use\' ]; then\n    NVM_CURRENT="$(nvm_ls_current)"\n    echo NVM_CURRENT="${NVM_CURRENT}"\n    if [ "_${NVM_CURRENT}" = \'_none\' ] || [ "_${NVM_CURRENT}" = \'_system\' ]; then\n      export TIMEFORMAT=\'%R nvm_resolve_local_alias\'\n      time VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)"\n      if [ -n "${VERSION}" ]; then\n        export TIMEFORMAT=\'%R nvm use\'\n        time nvm use --silent "${VERSION}" >/dev/null\n      elif nvm_rc_version >/dev/null 2>&1; then\n        nvm use --silent >/dev/null\n      fi\n    else\n      nvm use --silent "${NVM_CURRENT}" >/dev/null\n    fi\n  elif [ "_${NVM_MODE}" != \'_none\' ]; then\n    nvm_err \'Invalid auto mode supplied.\'\n    return 1\n  fi\n}\n')),(0,i.kt)("p",null,"In some places, I printed out the current time instead of timing the execution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'    "use")\n      local PROVIDED_VERSION\n      local NVM_SILENT\n      local NVM_SILENT_ARG\n      local NVM_DELETE_PREFIX\n      NVM_DELETE_PREFIX=0\n      local NVM_LTS\n\n      date +\'1 %s.%N\'\n      while [ $# -ne 0 ]; do\n        case "$1" in\n          --silent)\n            NVM_SILENT=1\n            NVM_SILENT_ARG=\'--silent\'\n          ;;\n          --delete-prefix) NVM_DELETE_PREFIX=1 ;;\n          --) ;;\n          --lts) NVM_LTS=\'*\' ;;\n          --lts=*) NVM_LTS="${1##--lts=}" ;;\n          --*) ;;\n          *)\n            if [ -n "${1-}" ]; then\n              PROVIDED_VERSION="$1"\n            fi\n          ;;\n        esac\n        shift\n      done\n\n      date +\'2 %s.%N\'\n      if [ -n "${NVM_LTS-}" ]; then\n        VERSION="$(nvm_match_version "lts/${NVM_LTS:-*}")"\n      elif [ -z "${PROVIDED_VERSION-}" ]; then\n        NVM_SILENT="${NVM_SILENT:-0}" nvm_rc_version\n        if [ -n "${NVM_RC_VERSION-}" ]; then\n          PROVIDED_VERSION="${NVM_RC_VERSION}"\n          VERSION="$(nvm_version "${PROVIDED_VERSION}")"\n        fi\n        unset NVM_RC_VERSION\n        if [ -z "${VERSION}" ]; then\n          nvm_err \'Please see `nvm --help` or https://github.com/nvm-sh/nvm#nvmrc for more information.\'\n          return 127\n        fi\n      else\n        VERSION="$(nvm_match_version "${PROVIDED_VERSION}")"\n      fi\n\n      if [ -z "${VERSION}" ]; then\n        >&2 nvm --help\n        return 127\n      fi\n')),(0,i.kt)("p",null,"However, now the output seems a bit strange:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt"},"0.053 /home/william/.bashrc.d/00-default.bashrc\n0.000 /home/william/.bashrc.d/50-android-sdk.bashrc\n0.000 /home/william/.bashrc.d/50-android-studio.bashrc\n0.003 /home/william/.bashrc.d/50-asdf.bashrc\nnvm_auto use\nNVM_CURRENT=none\n0.126 nvm_resolve_local_alias\n0.013 nvm_resolve_alias\n0.009 nvm_resolve_alias\n0.158 nvm use\n0.287 nvm use\n0.324 nvm use\n0.041 /home/william/.bashrc.d/50-sdkman.bashrc\n0.000 /home/william/.bashrc.d/90-gradle-opts.bashrc\n0.028 bashrc check\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it seemed like ",(0,i.kt)("inlineCode",{parentName:"li"},"50-nvm.bashrc")," was never executed at all -- but this is obviously false, because it was executed"),(0,i.kt)("li",{parentName:"ul"},"it seemed like there were multiple invocations of ",(0,i.kt)("inlineCode",{parentName:"li"},"nvm use")),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"date")," command didn't seem to be executed -- or is it?")),(0,i.kt)("p",null,"For the missing ",(0,i.kt)("inlineCode",{parentName:"p"},"date")," command output, it's just a matter of shell redirection. Removing the stdout redirection to ",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/null")," shows the output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_auto() {\n  echo nvm_auto "$@"\n  local NVM_MODE\n  NVM_MODE="${1-}"\n  local VERSION\n  local NVM_CURRENT\n  if [ "_${NVM_MODE}" = \'_install\' ]; then\n    VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)"\n    if [ -n "${VERSION}" ]; then\n      nvm install "${VERSION}" >/dev/null\n    elif nvm_rc_version >/dev/null 2>&1; then\n      nvm install >/dev/null\n    fi\n  elif [ "_$NVM_MODE" = \'_use\' ]; then\n    NVM_CURRENT="$(nvm_ls_current)"\n    echo NVM_CURRENT="${NVM_CURRENT}"\n    if [ "_${NVM_CURRENT}" = \'_none\' ] || [ "_${NVM_CURRENT}" = \'_system\' ]; then\n      export TIMEFORMAT=\'%R nvm_resolve_local_alias\'\n      time VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)"\n      if [ -n "${VERSION}" ]; then\n        export TIMEFORMAT=\'%R nvm use\'\n        time nvm use --silent "${VERSION}"\n      elif nvm_rc_version >/dev/null 2>&1; then\n        nvm use --silent >/dev/null\n      fi\n    else\n      nvm use --silent "${NVM_CURRENT}" >/dev/null\n    fi\n  elif [ "_${NVM_MODE}" != \'_none\' ]; then\n    nvm_err \'Invalid auto mode supplied.\'\n    return 1\n  fi\n}\n')),(0,i.kt)("p",null,"The stderr redirection is not a problem, it can stay there. The ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," command output is a bit more involved, though."),(0,i.kt)("p",null,"After reading through the source code, I realized that it was because the environment variable ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT")," kept getting overwritten by our ",(0,i.kt)("inlineCode",{parentName:"p"},"export")," calls. This means that all of these actions are executed inside the current shell context, so every time we do an ",(0,i.kt)("inlineCode",{parentName:"p"},"export TIMEFORMAT=..."),", we are actually overwriting that environment variable. Actually, if we see that all the functions are defined as ",(0,i.kt)("inlineCode",{parentName:"p"},"function_name() { ... }"),", we know that the commands inside the function is executed in the same shell context as the caller."),(0,i.kt)("p",null,"Meanwhile, the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT")," is evaluated when the command executed by ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," returns or exits, so if it was modified during the execution of the command, then the time printed will follow whatever ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT")," contains at that time."),(0,i.kt)("p",null,"On the other hand, we actually need all of this to be executed in the same shell context, so that the functions can define environment variables that we can use later. Sidenote: this is the only valid function definition in POSIX shell."),(0,i.kt)("p",null,"So basically what we need to do is, save the environment variable ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT")," before timing the command execution."),(0,i.kt)("h2",{id:"a-naive-fix"},'A naive "fix"'),(0,i.kt)("p",null,"So I attempted a naive fix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_process_parameters() {\n  local NVM_AUTO_MODE\n  NVM_AUTO_MODE=\'use\'\n  while [ $# -ne 0 ]; do\n    case "$1" in\n      --install) NVM_AUTO_MODE=\'install\' ;;\n      --no-use) NVM_AUTO_MODE=\'none\' ;;\n    esac\n    shift\n  done\n  _TIMEFORMAT="${TIMEFORMAT}"\n  export TIMEFORMAT=\'%R nvm_auto\'\n  time nvm_auto "${NVM_AUTO_MODE}"\n  export TIMEFORMAT="${_TIMEFORMAT}"\n}\n\nnvm_process_parameters "$@"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_auto() {\n  echo nvm_auto "$@"\n  local NVM_MODE\n  NVM_MODE="${1-}"\n  local VERSION\n  local NVM_CURRENT\n  if [ "_${NVM_MODE}" = \'_install\' ]; then\n    VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)"\n    if [ -n "${VERSION}" ]; then\n      nvm install "${VERSION}" >/dev/null\n    elif nvm_rc_version >/dev/null 2>&1; then\n      nvm install >/dev/null\n    fi\n  elif [ "_$NVM_MODE" = \'_use\' ]; then\n    NVM_CURRENT="$(nvm_ls_current)"\n    echo NVM_CURRENT="${NVM_CURRENT}"\n    if [ "_${NVM_CURRENT}" = \'_none\' ] || [ "_${NVM_CURRENT}" = \'_system\' ]; then\n      _TIMEFORMAT="${TIMEFORMAT}"\n      export TIMEFORMAT=\'%R nvm_resolve_local_alias\'\n      time VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)"\n      export TIMEFORMAT="${_TIMEFORMAT}"\n      if [ -n "${VERSION}" ]; then\n        _TIMEFORMAT="${TIMEFORMAT}"\n        export TIMEFORMAT=\'%R nvm use\'\n        time nvm use --silent "${VERSION}"\n        export TIMEFORMAT="${_TIMEFORMAT}"\n      elif nvm_rc_version >/dev/null 2>&1; then\n        nvm use --silent >/dev/null\n      fi\n    else\n      nvm use --silent "${NVM_CURRENT}" >/dev/null\n    fi\n  elif [ "_${NVM_MODE}" != \'_none\' ]; then\n    nvm_err \'Invalid auto mode supplied.\'\n    return 1\n  fi\n}\n')),(0,i.kt)("p",null,"Now we see that ",(0,i.kt)("inlineCode",{parentName:"p"},"date")," is doing its job, but the output from the ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," statements still seem wrong:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt"},"0.057 /home/william/.bashrc.d/00-default.bashrc\n0.000 /home/william/.bashrc.d/50-android-sdk.bashrc\n0.000 /home/william/.bashrc.d/50-android-studio.bashrc\n0.003 /home/william/.bashrc.d/50-asdf.bashrc\nnvm_auto use\nNVM_CURRENT=none\n0.131 nvm_resolve_local_alias\n0 1625994490.165539976\n1 1625994490.172686988\n2 1625994490.174463233\n0.012 nvm_resolve_alias\n3 1625994490.213854097\n0.010 nvm_resolve_alias\n4 1625994490.268562513\n5 1625994490.301861349\n6 1625994490.304278525\n7 1625994490.314978462\n0.152 nvm use\n0.286 nvm_auto\n0.313 nvm_auto\n0.040 /home/william/.bashrc.d/50-sdkman.bashrc\n0.000 /home/william/.bashrc.d/90-gradle-opts.bashrc\n0.020 bashrc check\n")),(0,i.kt)("h2",{id:"the-proper-fix"},"The proper fix"),(0,i.kt)("p",null,"Eventually I realized that we need to do a little bit more. When we save the contents of ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"_TIMEFORMAT"),", we are actually overwriting whatever is in ",(0,i.kt)("inlineCode",{parentName:"p"},"_TIMEFORMAT")," previously. What we actually need to do is, we need to use a different environment variable for each level of function invocation."),(0,i.kt)("p",null,"So this is the first level, which is OK:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_process_parameters() {\n  local NVM_AUTO_MODE\n  NVM_AUTO_MODE=\'use\'\n  while [ $# -ne 0 ]; do\n    case "$1" in\n      --install) NVM_AUTO_MODE=\'install\' ;;\n      --no-use) NVM_AUTO_MODE=\'none\' ;;\n    esac\n    shift\n  done\n  _TIMEFORMAT="${TIMEFORMAT}"\n  export TIMEFORMAT=\'%R nvm_auto\'\n  time nvm_auto "${NVM_AUTO_MODE}"\n  export TIMEFORMAT="${_TIMEFORMAT}"\n}\n\nnvm_process_parameters "$@"\n')),(0,i.kt)("p",null,"It calls ",(0,i.kt)("inlineCode",{parentName:"p"},"nvm_auto"),", which is the second level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_auto() {\n  echo nvm_auto "$@"\n  local NVM_MODE\n  NVM_MODE="${1-}"\n  local VERSION\n  local NVM_CURRENT\n  if [ "_${NVM_MODE}" = \'_install\' ]; then\n    VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)"\n    if [ -n "${VERSION}" ]; then\n      nvm install "${VERSION}" >/dev/null\n    elif nvm_rc_version >/dev/null 2>&1; then\n      nvm install >/dev/null\n    fi\n  elif [ "_$NVM_MODE" = \'_use\' ]; then\n    NVM_CURRENT="$(nvm_ls_current)"\n    echo NVM_CURRENT="${NVM_CURRENT}"\n    if [ "_${NVM_CURRENT}" = \'_none\' ] || [ "_${NVM_CURRENT}" = \'_system\' ]; then\n      __TIMEFORMAT="${TIMEFORMAT}"\n      export TIMEFORMAT=\'%R nvm_resolve_local_alias\'\n      time VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)"\n      export TIMEFORMAT="${__TIMEFORMAT}"\n      if [ -n "${VERSION}" ]; then\n        __TIMEFORMAT="${TIMEFORMAT}"\n        export TIMEFORMAT=\'%R nvm use\'\n        time nvm use --silent "${VERSION}"\n        export TIMEFORMAT="${__TIMEFORMAT}"\n      elif nvm_rc_version >/dev/null 2>&1; then\n        nvm use --silent >/dev/null\n      fi\n    else\n      nvm use --silent "${NVM_CURRENT}" >/dev/null\n    fi\n  elif [ "_${NVM_MODE}" != \'_none\' ]; then\n    nvm_err \'Invalid auto mode supplied.\'\n    return 1\n  fi\n}\n')),(0,i.kt)("p",null,"Note that within the same function, we don't need to use different variables to save ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT"),". This is because the ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," invocations are not nested. However, in the above example, we need to use yet another variable in ",(0,i.kt)("inlineCode",{parentName:"p"},"nvm_resolve_local_alias"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_resolve_local_alias() {\n  if [ -z "${1-}" ]; then\n    return 1\n  fi\n\n  local VERSION\n  local EXIT_CODE\n  ___TIMEFORMAT="${TIMEFORMAT}"\n  export TIMEFORMAT=\'%R nvm_resolve_alias\'\n  time VERSION="$(nvm_resolve_alias "${1-}")"\n  EXIT_CODE=$?\n  export TIMEFORMAT="${___TIMEFORMAT}"\n  if [ -z "${VERSION}" ]; then\n    return $EXIT_CODE\n  fi\n  if [ "_${VERSION}" != \'_\u221e\' ]; then\n    nvm_version "${VERSION}"\n  else\n    nvm_echo "${VERSION}"\n  fi\n}\n')),(0,i.kt)("p",null,"(note that we need to save the return value before restoring the ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMEFORMAT")," variable -- otherwise it will also be overwritten)"),(0,i.kt)("p",null,"Now, the output looks correct, and we know the execution time of the separate function calls:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt"},"0.053 /home/william/.bashrc.d/00-default.bashrc\n0.000 /home/william/.bashrc.d/50-android-sdk.bashrc\n0.000 /home/william/.bashrc.d/50-android-studio.bashrc\n0.002 /home/william/.bashrc.d/50-asdf.bashrc\nnvm_auto use\nNVM_CURRENT=none\n0.108 nvm_resolve_local_alias\n0 1625995040.289644320\n1 1625995040.293696818\n2 1625995040.294921503\n0.007 nvm_resolve_alias\n3 1625995040.336312682\n0.011 nvm_resolve_alias\n4 1625995040.385616982\n5 1625995040.417216708\n6 1625995040.418956680\n7 1625995040.429000260\n0.142 nvm use\n0.253 nvm_auto\n0.278 /home/william/.bashrc.d/50-nvm.bashrc\n0.039 /home/william/.bashrc.d/50-sdkman.bashrc\n0.000 /home/william/.bashrc.d/90-gradle-opts.bashrc\n0.018 bashrc check\n")),(0,i.kt)("p",null,"Note that we could not use arrays, because POSIX shell does not have an array type."),(0,i.kt)("h2",{id:"an-alternative-method"},"An alternative method"),(0,i.kt)("p",null,"There is an alternative method, which is simpler and shows the execution depth, but it is slower:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_process_parameters() {\n  local NVM_AUTO_MODE\n  NVM_AUTO_MODE=\'use\'\n  while [ $# -ne 0 ]; do\n    case "$1" in\n      --install) NVM_AUTO_MODE=\'install\' ;;\n      --no-use) NVM_AUTO_MODE=\'none\' ;;\n    esac\n    shift\n  done\n  export TIMEFORMAT="${TIMEFORMAT} / nvm_auto"\n  time nvm_auto "${NVM_AUTO_MODE}"\n  export TIMEFORMAT="${TIMEFORMAT% / nvm_auto}"\n}\n\nnvm_process_parameters "$@"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_auto() {\n  echo nvm_auto "$@"\n  local NVM_MODE\n  NVM_MODE="${1-}"\n  local VERSION\n  local NVM_CURRENT\n  if [ "_${NVM_MODE}" = \'_install\' ]; then\n    VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)"\n    if [ -n "${VERSION}" ]; then\n      nvm install "${VERSION}" >/dev/null\n    elif nvm_rc_version >/dev/null 2>&1; then\n      nvm install >/dev/null\n    fi\n  elif [ "_$NVM_MODE" = \'_use\' ]; then\n    NVM_CURRENT="$(nvm_ls_current)"\n    echo NVM_CURRENT="${NVM_CURRENT}"\n    if [ "_${NVM_CURRENT}" = \'_none\' ] || [ "_${NVM_CURRENT}" = \'_system\' ]; then\n      export TIMEFORMAT="${TIMEFORMAT} / nvm_resolve_local_alias"\n      time VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)"\n      export TIMEFORMAT="${TIMEFORMAT% / nvm_resolve_local_alias}"\n      if [ -n "${VERSION}" ]; then\n        export TIMEFORMAT="${TIMEFORMAT} / nvm use"\n        time nvm use --silent "${VERSION}"\n        export TIMEFORMAT="${TIMEFORMAT% / nvm use}"\n      elif nvm_rc_version >/dev/null 2>&1; then\n        nvm use --silent >/dev/null\n      fi\n    else\n      nvm use --silent "${NVM_CURRENT}" >/dev/null\n    fi\n  elif [ "_${NVM_MODE}" != \'_none\' ]; then\n    nvm_err \'Invalid auto mode supplied.\'\n    return 1\n  fi\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'nvm_resolve_local_alias() {\n  if [ -z "${1-}" ]; then\n    return 1\n  fi\n\n  local VERSION\n  local EXIT_CODE\n  export TIMEFORMAT="${TIMEFORMAT} / nvm_resolve_alias"\n  time VERSION="$(nvm_resolve_alias "${1-}")"\n  EXIT_CODE=$?\n  export TIMEFORMAT="${TIMEFORMAT% / nvm_resolve_alias}"\n  if [ -z "${VERSION}" ]; then\n    return $EXIT_CODE\n  fi\n  if [ "_${VERSION}" != \'_\u221e\' ]; then\n    nvm_version "${VERSION}"\n  else\n    nvm_echo "${VERSION}"\n  fi\n}\n')),(0,i.kt)("p",null,"With this method, we get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0.058 /home/william/.bashrc.d/00-default.bashrc\n0.000 /home/william/.bashrc.d/50-android-sdk.bashrc\n0.000 /home/william/.bashrc.d/50-android-studio.bashrc\n0.005 /home/william/.bashrc.d/50-asdf.bashrc\nnvm_auto use\nNVM_CURRENT=none\n0.109 /home/william/.bashrc.d/50-nvm.bashrc / nvm_auto / nvm_resolve_local_alias\n0 1625995835.146498759\n1 1625995835.151210563\n2 1625995835.152251905\n0.009 /home/william/.bashrc.d/50-nvm.bashrc / nvm_auto / nvm use / nvm_resolve_alias\n3 1625995835.195350192\n0.011 /home/william/.bashrc.d/50-nvm.bashrc / nvm_auto / nvm use / nvm_resolve_alias\n4 1625995835.248658001\n5 1625995835.280006594\n6 1625995835.282036172\n7 1625995835.291081025\n0.148 /home/william/.bashrc.d/50-nvm.bashrc / nvm_auto / nvm use\n0.262 /home/william/.bashrc.d/50-nvm.bashrc / nvm_auto\n0.289 /home/william/.bashrc.d/50-nvm.bashrc\n0.040 /home/william/.bashrc.d/50-sdkman.bashrc\n0.000 /home/william/.bashrc.d/90-gradle-opts.bashrc\n0.025 bashrc check\n")),(0,i.kt)("p",null,"These two methods should be enough for now. I do wonder if we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," variables for this, and if we can actually avoid the ",(0,i.kt)("inlineCode",{parentName:"p"},"export"),"s -- well, that's another blog post for another day, and maybe I'll make a custom shell script to demonstrate that."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"All in all, today we have learned:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"there is almost always more than one way to do it"),(0,i.kt)("li",{parentName:"ol"},"shell is not that simple, we need to think of execution context before overwriting variables"),(0,i.kt)("li",{parentName:"ol"},"check to see if stdout is redirected, otherwise some output may be missing"),(0,i.kt)("li",{parentName:"ol"},"be careful when adding profiling into code, make sure that return values are saved")))}_.isMDXComponent=!0}}]);